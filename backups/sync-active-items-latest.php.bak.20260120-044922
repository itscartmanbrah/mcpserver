<?php
declare(strict_types=1);

// Allow CLI invocation:
// php sync-active-items-latest.php SYNC_TOKEN=... batch=50 cust_batch=200
if (PHP_SAPI === 'cli' && empty($_GET) && isset($argv)) {
    parse_str(implode('&', array_slice($argv, 1)), $_GET);
}

set_time_limit(0);
header('Content-Type: text/plain; charset=utf-8');

require __DIR__ . '/../../src/Bootstrap.php';

use App\Support\Db;

/* =========================
   Access gate (MASTER ONLY)
   ========================= */
$token = (string)($_GET['SYNC_TOKEN'] ?? ($_GET['token'] ?? ''));
$expected = (string)(getenv('SYNC_TOKEN') ?: '');

if ($expected === '') {
    http_response_code(500);
    exit("SYNC_TOKEN missing from environment (.env not loaded)\n");
}
if ($token === '') {
    http_response_code(403);
    exit("Forbidden: missing SYNC_TOKEN\n");
}
if (!hash_equals($expected, $token)) {
    http_response_code(403);
    exit("Forbidden: token mismatch\n");
}

/* =========================
   DB-backed sync lock
   ========================= */
function acquireSyncLock(PDO $pdo, string $name): void
{
    $stmt = $pdo->prepare('SELECT GET_LOCK(:name, 0)'); // 0 = fail fast
    $stmt->execute(['name' => $name]);
    $ok = (int)$stmt->fetchColumn();

    if ($ok !== 1) {
        http_response_code(409);
        exit("Sync already running\n");
    }
}

function releaseSyncLock(PDO $pdo, string $name): void
{
    $stmt = $pdo->prepare('SELECT RELEASE_LOCK(:name)');
    $stmt->execute(['name' => $name]);
}

/* =========================
   sync_runs logging
   ========================= */
function syncRunStart(PDO $pdo, string $jobName): int
{
    $stmt = $pdo->prepare("
        INSERT INTO sync_runs (job_name, started_at, status, message)
        VALUES (:job_name, NOW(), 'running', NULL)
    ");
    $stmt->execute([':job_name' => $jobName]);
    return (int)$pdo->lastInsertId();
}

function syncRunFinish(PDO $pdo, int $runId, string $status, ?string $message = null): void
{
    $stmt = $pdo->prepare("
        UPDATE sync_runs
        SET finished_at = NOW(),
            status = :status,
            message = :message
        WHERE id = :id
    ");
    $stmt->execute([
        ':status' => $status,
        ':message' => $message,
        ':id' => $runId,
    ]);
}

/* =========================
   CLI call helper (no Apache dependency)
   ========================= */
/**
 * Execute a local sync script as a separate PHP CLI process.
 * This keeps isolation (separate memory/time budget) without relying on Apache/http://localhost.
 *
 * Child scripts must support CLI args by including:
 * if (PHP_SAPI === 'cli' && empty($_GET) && isset($argv)) { parse_str(..., $_GET); }
 */
function callCli(string $scriptAbsPath, array $query): string
{
    $php = PHP_BINARY; // typically /usr/bin/php
    $args = [];

    foreach ($query as $k => $v) {
        // Build args like SYNC_TOKEN=... batch=50
        $args[] = $k . '=' . (is_bool($v) ? ($v ? '1' : '0') : (string)$v);
    }

    $cmd = escapeshellarg($php) . ' ' . escapeshellarg($scriptAbsPath) . ' ' .
        implode(' ', array_map('escapeshellarg', $args));

    $out = [];
    $code = 0;

    exec($cmd . ' 2>&1', $out, $code);

    $text = implode("\n", $out);
    if ($text !== '') {
        $text .= "\n";
    }

    if ($code !== 0) {
        throw new RuntimeException("CLI call failed (exit {$code}): {$scriptAbsPath}\n{$text}");
    }

    return $text;
}

/* =========================
   Main
   ========================= */
echo "SYNC ACTIVE ITEMS (LATEST)\n";
echo "Started: " . date('Y-m-d H:i:s') . "\n\n";

$pdo = Db::pdo();
$lockName = 'mcp_sync_active_items_latest';

acquireSyncLock($pdo, $lockName);

$jobName = 'sync-active-items-latest';
$runId = syncRunStart($pdo, $jobName);

try {
    $itemsBatch = (int)($_GET['batch'] ?? 50);
    if ($itemsBatch <= 0) $itemsBatch = 50;

    $custBatch = (int)($_GET['cust_batch'] ?? 200);
    if ($custBatch <= 0) $custBatch = 200;

    $snapshotBatch = (int)($_GET['snap_batch'] ?? 1000);
    if ($snapshotBatch < 100 || $snapshotBatch > 5000) $snapshotBatch = 1000;

    // Absolute paths to child scripts
    $syncDir = __DIR__;
    $scriptActiveItems  = $syncDir . '/get-all-active-items.php';
    $scriptDeletedItems = $syncDir . '/get-deleted-active-items.php';
    $scriptCustomers    = $syncDir . '/get-all-customers.php';
    $scriptSnapshot     = $syncDir . '/snapshot-inventory.php';

    // 1) Active items upsert
    echo "1) Running GetAllActiveItems sync...\n";
    echo "----------------------------------------\n";
    echo callCli($scriptActiveItems, [
        'SYNC_TOKEN' => $token,
        'batch' => $itemsBatch,
    ]);

    // 2) Deleted items marker
    echo "\n\n2) Running Deleted Items marker...\n";
    echo "----------------------------------------\n";
    echo callCli($scriptDeletedItems, [
        'SYNC_TOKEN' => $token,
    ]);

    // 3) Customers sync
    echo "\n\n3) Running Customers sync...\n";
    echo "----------------------------------------\n";
    echo callCli($scriptCustomers, [
        'SYNC_TOKEN' => $token,
        'batch' => $custBatch,
    ]);

    // 4) Inventory snapshot (NEW)
    echo "\n\n4) Capturing Inventory snapshot...\n";
    echo "----------------------------------------\n";
    echo callCli($scriptSnapshot, [
        'SYNC_TOKEN'  => $token,
        'sync_run_id' => $runId,
        'batch'       => $snapshotBatch,
    ]);

    syncRunFinish($pdo, $runId, 'success', 'OK');

    echo "\n\nFinished: " . date('Y-m-d H:i:s') . "\n";
    echo "DONE\n";
} catch (Throwable $e) {
    syncRunFinish($pdo, $runId, 'failed', $e->getMessage());
    http_response_code(500);
    echo "\nFAILED: " . $e->getMessage() . "\n";
} finally {
    releaseSyncLock($pdo, $lockName);
}

